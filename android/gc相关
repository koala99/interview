程序计数器、虚拟机栈、本地方法栈这3个区域是随线程而生而灭的，内存分配和回收都具备确定性，而Java堆和方法区则不一样，各线程共享，在运行时内存的分配与回收都是动态的，垃圾收集器所关注的是这部分内存。


   思考GC完成的3件事：

       1、哪些内存需要回收？即如何判断对象已经死亡；

       2、什么时候回收？即GC发生在什么时候？需要了解GC策略，与垃圾回收器实现有关；

       3、如何回收？即需要了解垃圾回收算法，及算法的实现--垃圾回收器；

       首先哪些内存需要被回收：
       
      引用计数算法:
      给对象添加一个引用计数器，每当有一个地方引用它，计数器加1；
      当引用失效，计数器值减1；
      任何时刻计数器值为0，则认为对象是不再被使用的；    
     
     优点
      实现简单，判定高效，可以很好解决大部分场景的问题，也有一些著名的应用案例；
   缺点
    很难解决对象之间相互循环引用的问题;并且开销较大，频繁且大量的引用变化，带来大量的额外运算；

    可达性分析算法：
      通过一系列"GC Roots"对象作为起始点，开始向下搜索；
      搜索所走过和路径称为引用链（Reference Chain）；
      当一个对象到GC Roots没有任何引用链相连时（从GC Roots到这个对象不可达），则证明该对象是不可用的；
      Java中，GC Roots对象包括：
      （1）、虚拟机栈（栈帧中本地变量表）中引用的对象；
      （2）、方法区中类静态属性引用的对象；
      （3）、方法区中常量引用的对象；
      （4）、本地方法栈中JNI（Native方法）引用的对象；

   优点
        更加精确和严谨，可以分析出循环数据结构相互引用的情况；
缺点
  实现比较复杂；需要分析大量数据，消耗大量时间；分析过程需要GC停顿（引用关系不能发生变化），即停顿所有Java执行线程（称为"Stop The World"，是垃圾回收重点关注的问题）；

判断对象生存还是死亡：
要真正宣告一个对象死亡，至少要经历两次标记过程。

1、第一次标记
      在可达性分析后发现到GC Roots没有任何引用链相连时，被第一次标记；
      并且进行一次筛选：此对象是否必要执行finalize()方法；

（A）没有必要执行
      （1）对象没有覆盖finalize()方法；
      （2）finalize()方法已经被JVM调用过；
        这两种情况就可以认为对象已死，可以回收；
（B）有必要执行
         对有必要执行finalize()方法的对象，被放入F-Queue队列中；
        稍后在JVM自动建立、低优先级的Finalizer线程（可能多个线程）中触发这个方法；

2、第二次标记
      GC将对F-Queue队列中的对象进行第二次小规模标记；
      finalize()方法是对象逃脱死亡的最后一次机会：
      （A）、如果对象在其finalize()方法中重新与引用链上任何一个对象建立关联，第二次标记时会将其移出"即将回收"的集合；
      （B）、如果对象没有，也可以认为对象已死，可以回收了；                    
      一个对象的finalize()方法只会被系统自动调用一次，经过finalize()方法逃脱死亡的对象，第二次不会再调用；