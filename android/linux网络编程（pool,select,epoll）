同其他IO的不同的是,IO多路复用一次可以等多个文件描述符。大大提高了等待数据准备好的时间的效率。为了完成等的效率，系统提供了三个系统调用：select，poll，epoll。
这里不再讲述三者具体实现，只总结三者的优缺点。

select的缺点

1.单个进程监控的文件描述符有限，通常为1024*8个文件描述符。

当然可以改进，由于select采用轮询方式扫描文件描述符。文件描述符数量越多，性能越差。

2.内核/用户数据拷贝频繁，操作复杂。

select在调用之前，需要手动在应用程序里将要监控的文件描述符添加到fed_set集合中。然后加载到内核进行监控。用户为了检测时间是否发生，还需要在用户程序手动维护一个数组，存储监控文件描述符。当内核事件发生，在将fed_set集合中没有发生的文件描述符清空，然后拷贝到用户区，和数组中的文件描述符进行比对。再调用selecct也是如此。每次调用，都需要了来回拷贝。

3.轮回时间效率低

select返回的是整个数组的句柄。应用程序需要遍历整个数组才知道谁发生了变化。轮询代价大。

4、select是水平触发

应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作。那么之后select调用还是会将这些文件描述符返回，通知进程。

poll特点
1.poll操作比select稍微简单点。select采用三个位图来表示fd_set，poll使用pollfd的指针

pollfd结构包含了要监视的event和发生的evevt，不再使用select传值的方法。更方便

2.select的缺点依然存在。

拿select为例，加入我们的服务器需要支持100万的并发连接。则在FD_SETSIZE为1024的情况下，我们需要开辟100个并发的进程才能实现并发连接。除了进程上下调度的时间消耗外。从内核到用户空间的无脑拷贝，数组轮询等，也是系统难以接受的。因此，基于select实现一个百万级别的并发访问是很难实现的。

epoll模型
由于epoll和上面的实现机制完全不同，所以上面的问题将在epoll中不存在。

在select/poll中，服务器进程每次调用select都需要把这100万个连接告诉操作系统（从用户态拷贝到内核态）。让操作系统检测这些套接字是否有时间发生。轮询完之后，再将这些句柄数据复制到操作系统中，让服务器进程轮询处理已发生的网络时间。这一过程耗时耗力，
